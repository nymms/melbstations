<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melb PT Departure Board</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @font-face {
            font-family: 'Network Sans 2019';
            src: url('https://raw.githubusercontent.com/nymms/melbstations/main/NETWORKSANS-2019-REGULAR.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Network Sans 2019';
            src: url('https://raw.githubusercontent.com/nymms/melbstations/main/NETWORKSANS-2019-MEDIUM.TTF') format('truetype');
            font-weight: 600;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Network Sans 2019';
            src: url('https://raw.githubusercontent.com/nymms/melbstations/main/NETWORKSANS-2019-BOLD.TTF') format('truetype');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: 'Network Sans 2019', Arial, sans-serif;
            background-color: #000;
            color: #333434;
        }

        /* The station board is now the hover zone for the header */
        .station-board {
            width: 800px;
            margin: 0 auto;
            position: relative;
            left: 0;
        }

        /* Hidden checkbox to manage the 'pinned' state with pure CSS */
        .hidden-pin-toggle {
            display: none;
        }

        .pin-button {
            position: absolute;
            top: 150px;
            left: -5px;
            cursor: pointer;
            z-index: 1002;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .pin-button svg {
            width: 24px;
            height: 24px;
            fill: #333434; /* Light grey for the unpinned state */
            transition: transform 0.3s ease-out;
        }

        .pin-button:hover svg {
            fill: #707372;
            transition: transform 0.3s ease-out;
        }

        /* Rotate the pin and change its color when it's in the 'checked' state */
        .hidden-pin-toggle:checked + .pin-button svg {
            transform: rotate(45deg);
            fill: #707372; /* Darker grey for the pinned state */
        }

        .settings {
            /* Settings now use flex to place select boxes on a single line */
            display: flex;
            align-items: center;
            gap: 10px; /* Space between the two select boxes */
            padding: 12px;
            /* Hidden by default, toggled via JS */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            position: relative;
            left: 60px;
            width: 100%;
            z-index: 1000;
        }

        /* Settings Auto-Hide: Visible ONLY when hovering over the board AND the .visible class is present. (Pin state is ignored.) */
        .station-board:hover .settings.visible {
            opacity: 1;
            visibility: visible;
        }

        .station-header {
            width: 100%;
            background-color: #fff;
            padding: 12px;
            text-align: center;
            border-radius: 8px 8px 24px 24px;
            box-shadow: inset 0 8px 8px -10px rgba(0, 0, 0, 0.8);
            /* Start hidden above the viewport, accounting for its bottom margin */
            margin-top: calc(-1 * (var(--header-height, 130px) + 12px));
            transition: margin-top 0.5s ease-out;
            position: relative;
            z-index: 1001;
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }

        /* The header becomes visible when the pin is checked OR the board is hovered over and the pin is NOT checked */
        .hidden-pin-toggle:checked ~ .station-header,
        .station-board:hover .hidden-pin-toggle:not(:checked) ~ .station-header {
            margin-top: 0; /* Pushes the header down into view */
        }
        
        .station-name {
            font-size: 56px;
            font-weight: 600;
            padding-top: 16px;
            border-top: 16px solid #0072CE;
            margin-bottom: 10px;
            width: 100%;
            height: 100px
        }

        .departure-item {
            --route-bg-color: #95979A;
            --route-text-color: #000000;

            background-color: #fff;
            margin: 0 auto 5px auto;
            overflow: hidden;
        }
        
        .departure-header {
            padding: 15px 20px 0px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 16px solid var(--route-bg-color, #95979A);
            height: 70px;
        }
        
        .time-destination {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .departure-time {
            font-size: 38px;
            font-family: 'Network Sans 2019', Arial, sans-serif;
            color: #000;
        }
        
        .destination {
            font-size: 42px;
            font-family: 'Network Sans 2019', Arial, sans-serif;
            font-weight: 600;
            color: #000;
        }
        
        .alert-icon {
            width: 32px;
            height: 32px;
            background-color: #FE5000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 24px;
        }
        
        .time-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .delay-indicator {
            color: #FE5000;
            font-size: 28px;
            font-weight: bold;
        }
        
        .duration {
            background-color: #000;
            color: #fff;
            padding: 8px;
            font-size: 28px;
            font-weight: normal;
            min-width: 100px;
            text-align: center;
            height: 50px;
        }

        .route-info {
            padding: 8px 20px 8px 20px;
            font-size: 24px;
            font-weight: 200;
            color: #000;
            justify-content: space-between;
            align-items: center;
            height: 50px;
        }
        
        .departure-header .platform {
            background-color: var(--route-bg-color, #95979A);
            color: var(--route-text-color, #000000);
            padding: 8px;
            font-size: 28px;
            font-weight: 900;
            width: 40px;
            height: 50px;
            text-align: center;
        }

        .station-header .platform {
            font-size: 90px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 0px;
            margin-left: 10px;
            flex-shrink: 0;
            width: 100px;
            height: 120px;
            border-left: solid 2px #95979A;

        }

        /* Route colors */
        .route-color {color: #95979A;}
        .route-bgcolor {background-color: #95979A; color: #000000;}

        .next-stations {
            padding: 0px 20px 15px 0px;
            margin-left: 20px;
            margin-right: 20px;
            border-top: 3px solid #000;
            min-height: 300px;
        }

        .stations-list {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
        }

        .stations-column {
            display: flex;
            flex-direction: column;
            width: 33%;
            padding-top: 12px;
            background-repeat: no-repeat;
            position: relative;
        }

        .stations-column::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 25px;
            height: 25px;
            background-color: var(--route-bg-color, #95979A);
            z-index: 1;
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="11" y1="8" x2="11" y2="20" stroke="black" stroke-width="22" stroke-linecap="butt"/><line x1="11" y1="28" x2="11" y2="40" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="11" y1="8" x2="11" y2="20" stroke="black" stroke-width="22" stroke-linecap="butt"/><line x1="11" y1="28" x2="11" y2="40" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
        }

        .stations-column:first-child::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 25px;
            height: 25px;
            background-color: var(--route-bg-color, #95979A);
            z-index: 1;
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="11" y1="0" x2="11" y2="75" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="11" y1="0" x2="11" y2="75" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
        }

        .stations-column:first-child {
            padding-top: 8px;
        }

        .next-station {
            color: #000;
            font-size: 22px;
            font-weight: normal;
            padding-left: 20px;
            position: relative;
            display: flex;
            align-items: center;
            border-left: 6px solid var(--route-bg-color, #95979A);
        }

        .next-station::before {
            content: '◼︎';
            font-weight: 900;
            font-size: 12px;
            position: absolute;
            left: -2px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            color: var(--route-bg-color, #95979A);
        }

        .next-station.current {
            color: #000;
            border-left: 6px solid var(--route-bg-color, #95979A);
        }

        .next-station.current .station-text {
            padding: 2px 4px;
            background-color: var(--route-bg-color, #95979A);
            color: var(--route-text-color, #95979A);
        }

        .next-station.last-station {
            border-left: none !important;
            padding-left: 25px;
        }

        .next-station.last-station::after {
            display: none !important;
        }

        /* terminating station T symbol */
        .next-station.last-station::before {
            content: '';
            display: inline-block;
            position: absolute;
            left: -10px;
            top: 8px;
            width: 25px;
            height: 25px;
            background-color: var(--route-bg-color, #95979A);
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="20" y1="75" x2="80" y2="75" stroke="black" stroke-width="22" stroke-linecap="butt"/><line x1="50" y1="0" x2="50" y2="75" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="20" y1="75" x2="80" y2="75" stroke="black" stroke-width="22" stroke-linecap="butt"/><line x1="50" y1="0" x2="50" y2="75" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
        }

        /* station route continuation dashes */
        .stations-column .next-station:last-child:not(.last-station)::after {
            content: '';
            position: absolute;
            left: -6px;
            top: 41px;
            transform: translateY(-50%);
            width: 25px;
            height: 25px;
            background-color: var(--route-bg-color, #95979A);
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="11" y1="8" x2="11" y2="20" stroke="black" stroke-width="22" stroke-linecap="butt"/><line x1="11" y1="28" x2="11" y2="40" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><line x1="11" y1="8" x2="11" y2="20" stroke="black" stroke-width="22" stroke-linecap="butt"/><line x1="11" y1="28" x2="11" y2="40" stroke="black" stroke-width="22" stroke-linecap="butt"/></svg>');
        }

        .last-updated {
            font-size: 8px;
            padding: 2px;
            color: #d3d3d3;
        }

        #settingsButton {
            background: none;
            border: none;
            cursor: pointer;
            outline: none;
            display: inline-flex;
            align-items: center;
            position: absolute; /* Position button within the header/board */
            left: 27px; /* Aligned to the right */
            top: 150px; /* Pushed down slightly */
            z-index: 1003;
        }

        #settingsButton svg {
            margin: 5px; 
            width: 20px;
            height: 20px;
            display: block; 
            fill: #ededed; /* Initial color when hidden (light gray) */
        }

        #settingsButton:hover #gearOutline {
            fill: #707372; 
        } 
        #gearOutline {
            transition: fill 0.3s ease;
        }

        .settings select {
            padding: 2px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .no-trains {
            font-size: 42px;
            font-weight: 600;
            text-align: center;
            color: #333434;
            top: 50px;
        }

        /* train icon */
        .no-trains:before {
            text-align: center;
            width: 180px;
            left: 35%;
            display: block;
            position: relative;
            content: url('data:image/svg+xml;utf8,<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g transform="matrix(0.240385,0,0,0.240385,-36.1594,-13.7553)"><path d="M282.232,285.192C285.688,285.192 288.568,282.312 288.568,278.856C288.568,275.4 285.688,272.52 282.232,272.52C278.776,272.52 275.896,275.4 275.896,278.856C275.896,282.312 278.776,285.192 282.232,285.192ZM299.224,285.192C302.68,285.192 305.272,282.312 305.272,278.856C305.272,275.4 302.68,272.52 299.224,272.52C295.768,272.52 292.888,275.4 292.888,278.856C292.888,282.312 295.768,285.192 299.224,285.192ZM359.704,285.192C363.16,285.192 366.04,282.312 366.04,278.856C366.04,275.4 363.16,272.52 359.704,272.52C356.248,272.52 353.368,275.4 353.368,278.856C353.368,282.312 356.248,285.192 359.704,285.192ZM376.408,285.192C380.152,285.192 382.744,282.312 382.744,278.856C382.744,275.4 380.152,272.52 376.408,272.52C372.952,272.52 370.36,275.4 370.36,278.856C370.36,282.312 372.952,285.192 376.408,285.192Z" style="fill-rule:nonzero;"/></g><g transform="matrix(0.240385,0,0,0.240385,-86.577,-13.7553)"><g transform="matrix(1,0,0,1,-29.12,0)"><path d="M628.656,305.928L508.272,305.928C497.904,305.928 489.264,297.576 489.264,287.208L489.264,286.92L496.176,191.592L496.176,191.88C496.176,181.512 504.816,172.872 515.184,172.872L621.456,172.872C632.112,172.872 640.464,181.512 640.464,191.88L640.464,191.592L647.664,286.92L647.664,287.208C647.664,297.576 639.024,305.928 628.656,305.928Z" style="fill:none;fill-rule:nonzero;stroke:black;stroke-width:8.32px;"/></g><g transform="matrix(1,0,0,1.02439,-29.8,-6.432)"><path d="M611,208.008C611,206.348 609.619,205 607.918,205L530.082,205C528.381,205 527,206.348 527,208.008L524,242.992C524,244.652 525.381,246 527.082,246L610.918,246C612.619,246 614,244.652 614,242.992L611,208.008Z" style="fill:none;fill-rule:nonzero;stroke:black;stroke-width:10.87px;stroke-linecap:round;stroke-miterlimit:1.5;"/></g><g transform="matrix(1,0,0,1,-29.12,0)"><path d="M568.464,203.568L568.464,245.568" style="fill:none;fill-rule:nonzero;stroke:black;stroke-width:5px;stroke-linecap:round;stroke-miterlimit:1.5;"/></g><g transform="matrix(1,0,0,1,159.539,5.01469)"><path d="M300,335L459,335" style="fill:none;fill-rule:nonzero;stroke:black;stroke-width:11px;stroke-linecap:round;stroke-miterlimit:1.5;"/></g><g transform="matrix(1,0,0,1,160.344,5.01469)"><path d="M314,316L444,316" style="fill:none;fill-rule:nonzero;stroke:black;stroke-width:5px;stroke-linecap:round;stroke-miterlimit:1.5;"/></g><g transform="matrix(1.34459,0,0,1,24.7651,5.01469)"><path d="M365,300.913L360,300.913C360,300.913 340.912,338.471 334.531,351.025C334.13,351.815 334.087,352.837 334.419,353.683C334.751,354.528 335.403,355.057 336.114,355.057L347.514,355.057C348.193,355.057 348.805,354.503 349.061,353.657C351.628,345.162 365,300.913 365,300.913Z" style="fill-rule:nonzero;"/></g><g transform="matrix(-1.34459,0,0,1,1053.7,5.01469)"><path d="M365,300.913L360,300.913C360,300.913 340.912,338.471 334.531,351.025C334.13,351.815 334.087,352.837 334.419,353.683C334.751,354.528 335.403,355.057 336.114,355.057L347.514,355.057C348.193,355.057 348.805,354.503 349.061,353.657C351.628,345.162 365,300.913 365,300.913Z" style="fill-rule:nonzero;"/></g></g><g transform="matrix(-2.67017,0,0,2.67017,100.916,10.1879)"><path d="M11.119,8.559C11.155,8.091 11.563,7.755 12.031,7.791C12.499,7.827 12.835,8.235 12.799,8.691C12.763,9.159 12.355,9.507 11.899,9.471C11.431,9.435 11.083,9.027 11.119,8.559Z" style="fill-rule:nonzero;"/></g><g transform="matrix(-2.67017,0,0,2.67017,100.916,10.1879)"><path d="M14.671,13.023C14.587,13.143 14.455,13.203 14.323,13.203C14.239,13.203 14.155,13.179 14.071,13.131L12.919,12.327C12.859,12.291 12.811,12.231 12.775,12.171L12.391,11.403L11.899,13.647L13.147,14.907C13.219,14.979 13.279,15.075 13.291,15.183L13.603,17.355C13.639,17.631 13.447,17.895 13.171,17.931L13.099,17.931C12.847,17.931 12.631,17.751 12.595,17.499L12.319,15.495L11.047,14.235L10.759,15.531C10.747,15.591 10.723,15.651 10.687,15.711L9.355,17.703C9.259,17.859 9.103,17.931 8.935,17.931C8.839,17.931 8.743,17.907 8.659,17.847C8.419,17.691 8.359,17.379 8.515,17.151L9.787,15.219L10.711,11.103L9.991,11.811L9.619,13.239C9.559,13.431 9.391,13.563 9.199,13.563C9.163,13.563 9.115,13.551 9.067,13.539C8.851,13.467 8.731,13.227 8.791,13.011L9.187,11.487C9.211,11.415 9.247,11.343 9.307,11.295L10.615,9.975C10.711,9.879 10.843,9.831 10.987,9.831L12.235,9.831C12.439,9.831 12.607,9.939 12.703,10.107L13.495,11.679L14.551,12.411C14.755,12.555 14.815,12.831 14.671,13.023Z" style="fill-rule:nonzero;"/></g><g transform="matrix(1.15158,0,0,1.15158,-3.80791,-4.41653)"><circle cx="46.367" cy="50.382" r="33.471" style="fill:none;stroke:rgb(207,32,47);stroke-width:1.3px;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;"/></g><path d="M23.427,25.305L75.868,81.789" style="fill:none;stroke:rgb(207,32,47);stroke-width:1.5px;stroke-linejoin:round;stroke-miterlimit:1.5;"/></svg>');
        }

        .departure-item:has(.no-trains) .next-stations {
            border: none;
        }

        .departure-item:has(.no-trains) .departure-header {
            border: none;
        }

        .network-dings {
            font-family: 'Network-Dings-2019';
            font-size: 72px;
        }

        /* Skipped station styling */
        .next-station.skipped {
            color: #D7D2CB;
        }

        .next-station.skipped .station-text {
            color: #D7D2CB;
        }

        /* Triangle marker for skipped stations (replacing square) */
        .next-station.skipped::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 97%;
            transform: translate(0, -50%); /* Added transform for vertical centering */
            width: 30px;
            height: 30px;
            background-color: white; 
            /* Use the LARGER SVG (full shape) */
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M4.172,11.07L23.998,33.89L43.828,11.07" style="fill:none;stroke:white;stroke-width:8px;"/></svg>');
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M4.172,11.07L23.998,33.89L43.828,11.07" style="fill:none;stroke:white;stroke-width:8px;"/></svg>');
        }

        .next-station.skipped::after {
            content: '';
            /* Match the position and size of ::before */
            position: absolute;
            left: -10px;
            top: 75%;
            transform: translate(0, -50%);
            width: 30px;
            height: 30px;
            /* This will be the FILL color (your required color) */
            background-color: var(--route-bg-color, #95979A); 
            /* Use the SMALLER SVG (the inner fill area) */
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M4.172,11.07L23.998,33.89L43.828,11.07" style="fill:none;stroke:black;stroke-width:12px;"/></svg>');
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M4.172,11.07L23.998,33.89L43.828,11.07" style="fill:none;stroke:black;stroke-width:12px;"/></svg>');
        }

        .next-station.skipped ~ .next-station.skipped:before {
            content: none;
        }

        .next-station.skipped ~ .next-station.skipped:after {
            content: none;
        }

    </style>
</head>
<body>
    <div class="station-board">
        <input type="checkbox" id="pin-toggle" class="hidden-pin-toggle">
        <label for="pin-toggle" class="pin-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M16 12V4H17V2H7V4H8V12L6 14V16H11.2V22H12.8V16H18V14L16 12Z" />
            </svg>
        </label>
        <div class="station-header">
            <div class="station-name"></div>
            <div class="platform"></div>
            <!-- The settings button is now INSIDE the header div -->
            <button id="settingsButton" aria-expanded="false" aria-controls="settings-panel" title="Toggle Settings">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                    <path id="gearOutline" d="M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" fill="#333434" />
                    <path d="M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" fill="#000000"/>
                </svg>
            </button>
        </div>
        <!-- The settings panel is now positioned directly after the header -->
        <div class="settings" id="settings-panel">
            <select id="stationSelect">
            <option value="">Select Station...</option>
            </select>
            <select id="platformSelect" style="width:40px;">
            <option value="">All Platforms</option>
            </select>
        </div>
        <div class="departure-item" style="display: block;">
            <div class="departure-header">
                <div class="time-destination">
                    <span class="departure-time"></span>
                    <span class="destination"></span>
                </div>
                <div class="time-info">
                    <div class="delay-indicator"></div>
                    <div class="duration"></div>
                </div>
            </div>
            <div class="route-info"><span></span></div>
            <div class="next-stations">
                <div class="stations-list">
                </div>
            </div>
            <div class="last-updated" id="lastUpdated">Loading...</div>
        </div>
    </div>
</body>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const departureItem = document.querySelector('.departure-item');
        const destinationElement = document.querySelector('.destination');
        const platformElement = document.querySelector('.departure-header .platform');
        const headerPlatformElement = document.querySelector('.station-header .platform');
        const stationNameElement = document.querySelector('.station-name');
        const lastUpdatedElement = document.getElementById('lastUpdated');
        const routeInfoElement = document.querySelector('.route-info span');
        const departureTimeElement = document.querySelector('.departure-time');
        const delayIndicatorElement = document.querySelector('.delay-indicator');
        const durationElement = document.querySelector('.duration');
        const headerElement = document.querySelector('.station-header');
        const stationBoardElement = document.querySelector('.station-board');
        const settingsButton = document.getElementById('settingsButton');
        const settingsPanel = document.getElementById('settings-panel');
        
        let currentStopId = 1127; // default
        let currentPlatform = "1"; // default platform 1
        let currentRunId = null;

        const getDepartureApiUrl = () => {
            const baseUrl = `https://melbptboard-opt.onrender.com/api/next-departure?stop_id=${currentStopId}`;
            return currentPlatform ? `${baseUrl}&platform=${currentPlatform}` : baseUrl;
        };
        
        let stationsData = null;

        const routeColors = {
            3: { background: '#FFBE00', text: '#000000' },
            14: { background: '#FFBE00', text: '#000000' },
            15: { background: '#FFBE00', text: '#000000' },
            6: { background: '#028430', text: '#FFFFFF' },
            16: { background: '#028430', text: '#FFFFFF' },
            17: { background: '#028430', text: '#FFFFFF' },
            12: { background: '#F178AF', text: '#000000' },
            4: { background: '#279FD5', text: '#000000' },
            11: { background: '#279FD5', text: '#000000' },
            2: { background: '#152C6B', text: '#FFFFFF' },
            9: { background: '#152C6B', text: '#FFFFFF' },
            1: { background: '#152C6B', text: '#FFFFFF' },
            7: { background: '#152C6B', text: '#FFFFFF' },
            5: { background: '#BE1014', text: '#FFFFFF' },
            8: { background: '#BE1014', text: '#FFFFFF' },
            88: { background: '#95979A', text: '#000000' },
            13: { background: '#95979A', text: '#000000' }
        };

        const loadStations = async () => {
            try {
                const response = await fetch('https://raw.githubusercontent.com/nymms/melbstations/main/stations.json');
                const data = await response.json();
                stationsData = data.stations;
            } catch (error) {
                console.error('Failed to load stations.json:', error);
            }
        };

        let routeOrderData = null;

        const loadRouteOrder = async () => {
            try {
                const response = await fetch('https://raw.githubusercontent.com/nymms/melbstations/main/route-order.json'); // Or your GitHub URL
                const data = await response.json();
                routeOrderData = data.routes;
            } catch (error) {
                console.error('Failed to load route-order.json:', error);
            }
        };

        const getRouteSegment = (routeId, currentStopId, finalStopId) => {
            if (!routeOrderData || !routeOrderData[routeId]) return null;
            
            const routeStops = routeOrderData[routeId].stops;
            
            // Find positions in the route order
            const currentPos = routeStops.findIndex(s => s.stop_id === currentStopId);
            const finalPos = routeStops.findIndex(s => s.stop_id === finalStopId);
            
            if (currentPos === -1 || finalPos === -1) return null;
            
            // Determine direction and extract segment
            let segment;
            if (currentPos < finalPos) {
                // Outbound: forward through array
                segment = routeStops.slice(currentPos, finalPos + 1);
            } else {
                // Inbound: reverse through array
                segment = routeStops.slice(finalPos, currentPos + 1).reverse();
            }
            
            return segment;
        };

        const detectExpressService = (routeSegment, actualStops) => {
            if (!routeSegment || routeSegment.length === 0) return { isExpress: false, skipped: [] };
            
            const actualStopIds = actualStops.map(s => s.stop_id);
            const skippedStations = [];
            let consecutiveSkips = 0;
            let maxConsecutiveSkips = 0;
            
            routeSegment.forEach(stop => {
                if (!actualStopIds.includes(stop.stop_id)) {
                    skippedStations.push(stop);
                    consecutiveSkips++;
                    maxConsecutiveSkips = Math.max(maxConsecutiveSkips, consecutiveSkips);
                } else {
                    consecutiveSkips = 0;
                }
            });
            
            return {
                isExpress: maxConsecutiveSkips >= 2,
                skipped: skippedStations,
                singleSkip: skippedStations.length === 1 ? skippedStations[0] : null
            };
        };

        const getStationName = (stopId) => {
            if (!stationsData) return `Stop ${stopId}`;
            const station = stationsData.find(s => s.stop_id === stopId);
            return station ? station.stop_name : `Stop ${stopId}`;
        };

        const populateStationDropdown = () => {
            const select = document.getElementById('stationSelect');
            if (stationsData) {
                stationsData.forEach(station => {
                    const option = document.createElement('option');
                    option.value = station.stop_id;
                    option.textContent = station.stop_name;
                    select.appendChild(option);
                });
                
                select.value = currentStopId;
                
                select.addEventListener('change', (e) => {
                    currentStopId = parseInt(e.target.value);
                    if (currentStopId) {
                        updatePlatformDropdown();
                        updateBoard();
                    }
                });
                
                const platformSelect = document.getElementById('platformSelect');
                platformSelect.addEventListener('change', (e) => {
                    currentPlatform = e.target.value;
                    updateBoard();
                });
            }
        };

        const updatePlatformDropdown = () => {
            const select = document.getElementById('platformSelect');
            const station = stationsData.find(s => s.stop_id === currentStopId);
            const platformCount = station ? station.number_of_platforms : 2;
            
            select.innerHTML = '<option value="">All Platforms</option>';
            
            for (let i = 1; i <= platformCount; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${i}`;
                select.appendChild(option);
            }
            
            select.value = platformCount >= 1 ? "1" : "";
            currentPlatform = select.value;
        };

        const loadStoppingPattern = async (runId) => {
            try {
                console.log('Loading stops for run_id:', runId);
                const response = await fetch(`https://melbptboard-opt.onrender.com/api/run/stops?run_id=${runId}`);
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    console.log('Response not OK');
                    return null;
                }
                
                const data = await response.json();
                console.log('Raw stops data:', data);
                console.log('Departures array:', data.departures);
                
                return data.stops || [];
            } catch (error) {
                console.error('Failed to load stopping pattern:', error);
                return null;
            }
        };  

        const calculateColumnDistribution = (numStops) => {
            if (numStops <= 7) {
                return { columns: 1, distribution: [numStops] };
            }
            
            if (numStops <= 14) {
                const col1 = Math.ceil(numStops / 2);
                const col2 = numStops - col1;
                return { columns: 2, distribution: [col1, col2] };
            }
            
            if (numStops <= 24) {
                const base = Math.floor(numStops / 3);
                const remainder = numStops % 3;
                const distribution = [base, base, base];
                
                for (let i = 0; i < remainder; i++) {
                    distribution[i]++;
                }
                return { columns: 3, distribution };
            }
            
            const col3 = numStops - 20;
            return { columns: 3, distribution: [10, 10, col3] };
        };

        // route-info analysis
        const analyzeInboundRoute = (stops, currentStopId) => {
            const cityStations = [1155, 1071, 1181, 1068, 1120];
            const loopStations = [1068, 1120, 1155]; // Flagstaff, Melbourne Central, Parliament
            
            const currentIndex = stops.findIndex(stop => stop.stop_id === currentStopId);
            if (currentIndex === -1) return null;
            
            const remainingStops = stops.slice(currentIndex);
            // Skip the current station when looking for future city stations
            const futureCityStationsOnly = remainingStops.slice(1).map(stop => stop.stop_id);

            // Check if any city stations are ahead
            const hasFutureCityStations = futureCityStationsOnly.some(id => cityStations.includes(id));
            if (!hasFutureCityStations) return null; // Not inbound

            // Find the first city station in the remaining journey
            const firstCityStation = futureCityStationsOnly.find(id => cityStations.includes(id));

            if (firstCityStation === 1071) {
                return "Direct to Flinders Street";
            }

            // For non-Flinders first stations, check pattern
            const hasLoopStations = futureCityStationsOnly.some(id => loopStations.includes(id));

            if (hasLoopStations) {
                return "via the City Loop";
            }

            if (firstCityStation === 1181) {
                return "via Southern Cross";
            }

            return "to City";
        };

        const analyzeOutboundRoute = (stops, currentStopId, expressInfo) => {
            const loopStations = [1068, 1120, 1155]; // Flagstaff, Melbourne Central, Parliament
            
            const currentIndex = stops.findIndex(stop => stop.stop_id === currentStopId);
            if (currentIndex === -1) return null;
            
            const remainingStops = stops.slice(currentIndex);
            const futureStopIds = remainingStops.map(stop => stop.stop_id);
            
            // Check if there are any future City Loop stations
            const hasFutureLoopStations = futureStopIds.some(id => loopStations.includes(id));
            
            // Build route description based on express detection
            let baseText = "Stopping all stations";
            
            if (expressInfo && expressInfo.isExpress) {
                baseText = "Express service";
            } else if (expressInfo && expressInfo.singleSkip) {
                const skippedStationName = getStationName(expressInfo.singleSkip.stop_id);
                baseText = `Stopping all stations except ${skippedStationName}`;
            }
            
            if (hasFutureLoopStations) {
                return `${baseText} via City Loop`;
            }
            
            return baseText;
        };

        const showNoDeparturesMessage = (platformFilter) => {
            // Clear the stations display
            const stationsList = document.querySelector('.stations-list');
            const existingColumns = stationsList.querySelectorAll('.stations-column');
            existingColumns.forEach(col => col.remove());
            
            // Hide all departure info elements
            if (departureTimeElement) departureTimeElement.style.display = 'none';
            if (delayIndicatorElement) delayIndicatorElement.style.display = 'none';
            if (durationElement) durationElement.style.display = 'none';
            if (platformElement) platformElement.style.display = 'none';
            if (routeInfoElement) routeInfoElement.textContent = '';
            
            // Show message in the route-info div
            const nextStationsDiv = document.querySelector('.route-info');
            if (nextStationsDiv) {
                nextStationsDiv.innerHTML = '<div class="no-trains">No trains are departing from<br>this platform</div>';
            }

            // Clear destination text
            if (destinationElement) {
                destinationElement.textContent = '';
            }
            
            if (lastUpdatedElement) {
                lastUpdatedElement.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
            }
            // Still show station name and platform info
            if (stationNameElement) {
                stationNameElement.textContent = getStationName(currentStopId);
            }

            if (headerPlatformElement) {
                headerPlatformElement.textContent = currentPlatform || '?';
            }
        };

        const restoreNormalDisplay = () => {
            // 1. Find the .route-info container
            const routeInfoContainer = document.querySelector('.departure-item .route-info');

            // 2. Reset the content of .route-info to its original state (containing only a span)
            if (routeInfoContainer) {
                routeInfoContainer.innerHTML = '<span></span>';
            }

            // 3. Clear the content of the *actual* .stations-list (which lives in the sibling .next-stations)
            const stationsList = document.querySelector('.stations-list');
            if (stationsList) {
                stationsList.innerHTML = '';
            }
            
            // Restore display properties for the next train data
            if (departureTimeElement) departureTimeElement.style.display = '';
            if (delayIndicatorElement) delayIndicatorElement.style.display = '';
            if (durationElement) durationElement.style.display = '';
            if (platformElement) platformElement.style.display = '';
            
            if (destinationElement) {
                destinationElement.style.textAlign = '';
                destinationElement.style.width = '';
            }
        };

        const populateStationDivs = (stops, currentStopId, finalStopId, routeId) => {
            console.log('populateStationDivs called with:', stops, currentStopId, finalStopId, routeId);
            
            const stationsList = document.querySelector('.stations-list');
            
            // Clear existing columns
            const existingColumns = stationsList.querySelectorAll('.stations-column');
            existingColumns.forEach(col => col.remove());
            
            if (!stops || stops.length === 0) {
                console.log('No stops data');
                return;
            }
            
            // Get the full route segment (all stations between current and final)
            let routeSegment = getRouteSegment(routeId, currentStopId, finalStopId);
            let cityStops = [];
            let suburbanStartIndex = 0;
            
            // If current station not in route order (likely a city station), find first suburban station
            if (!routeSegment) {
                console.log('Current station not in route order, searching for first suburban station');
                
                const currentIndex = stops.findIndex(stop => stop.stop_id === currentStopId);
                
                // Find the first stop that IS in the route order
                for (let i = currentIndex; i < stops.length; i++) {
                    const testSegment = getRouteSegment(routeId, stops[i].stop_id, finalStopId);
                    if (testSegment) {
                        routeSegment = testSegment;
                        suburbanStartIndex = i;
                        // City stops are everything before the first suburban stop
                        cityStops = stops.slice(currentIndex, i);
                        console.log('Found suburban portion starting at:', stops[i].stop_name, 'with', cityStops.length, 'city stops');
                        break;
                    }
                }
                
                if (!routeSegment) {
                    console.log('No route order data found, showing actual stops only');
                    const stopsToShow = currentIndex >= 0 ? stops.slice(currentIndex) : stops;
                    populateActualStopsOnly(stopsToShow, finalStopId);
                    return;
                }
            }
            
            // Get stops for suburban portion only (for express detection)
            const suburbanStops = stops.slice(suburbanStartIndex);
            
            // Detect express service on suburban portion
            const expressInfo = detectExpressService(routeSegment, suburbanStops);
            const actualStopIds = suburbanStops.map(s => s.stop_id);
            
            console.log('Express detection:', expressInfo);
            console.log('Route segment length:', routeSegment.length);
            console.log('City stops:', cityStops.length);
            
            // Calculate total stops to display (city + suburban route segment)
            const totalStops = cityStops.length + routeSegment.length;
            const { columns: numColumns, distribution } = calculateColumnDistribution(totalStops);
            
            // Create columns
            for (let i = 0; i < numColumns; i++) {
                const column = document.createElement('div');
                column.className = 'stations-column route-color';
                stationsList.appendChild(column);
            }
            
            const columns = stationsList.querySelectorAll('.stations-column');
            console.log('Created columns:', columns.length, 'Distribution:', distribution);
            
            // Populate all stations (city + suburban with skipped)
            let stationIndex = 0;
            
            for (let colIndex = 0; colIndex < numColumns; colIndex++) {
                const stationsInThisColumn = distribution[colIndex];
                
                for (let i = 0; i < stationsInThisColumn && stationIndex < totalStops; i++) {
                    let stationDiv, stationText;
                    
                    // First, render city stops (if any)
                    if (stationIndex < cityStops.length) {
                        const cityStop = cityStops[stationIndex];
                        stationDiv = document.createElement('div');
                        stationDiv.className = 'next-station route-color';
                        
                        if (stationIndex === 0) stationDiv.classList.add('current');
                        
                        stationText = document.createElement('span');
                        stationText.className = 'station-text';
                        stationText.textContent = getStationName(cityStop.stop_id);
                        
                    } else {
                        // Then render suburban stops (with skipped detection)
                        const suburbanIndex = stationIndex - cityStops.length;
                        const routeStop = routeSegment[suburbanIndex];
                        const isActualStop = actualStopIds.includes(routeStop.stop_id);
                        
                        stationDiv = document.createElement('div');
                        stationDiv.className = isActualStop ? 'next-station route-color' : 'next-station skipped route-color';
                        
                        if (stationIndex === 0) stationDiv.classList.add('current');
                        if (routeStop.stop_id === finalStopId) stationDiv.classList.add('last-station');
                        
                        stationText = document.createElement('span');
                        stationText.className = 'station-text';
                        stationText.textContent = getStationName(routeStop.stop_id);
                    }
                    
                    stationDiv.appendChild(stationText);
                    columns[colIndex].appendChild(stationDiv);
                    
                    stationIndex++;
                }
            }
            
            // Return express info for route-info usage
            return expressInfo;
        };

        // Fallback function for when no route order data available
        const populateActualStopsOnly = (stopsToShow, finalStopId) => {
            const stationsList = document.querySelector('.stations-list');
            const { columns: numColumns, distribution } = calculateColumnDistribution(stopsToShow.length);
            
            for (let i = 0; i < numColumns; i++) {
                const column = document.createElement('div');
                column.className = 'stations-column route-color';
                stationsList.appendChild(column);
            }
            
            const columns = stationsList.querySelectorAll('.stations-column');
            
            let stationIndex = 0;
            for (let colIndex = 0; colIndex < numColumns; colIndex++) {
                const stationsInThisColumn = distribution[colIndex];
                
                for (let i = 0; i < stationsInThisColumn && stationIndex < stopsToShow.length; i++) {
                    const stop = stopsToShow[stationIndex];
                    const stationDiv = document.createElement('div');
                    stationDiv.className = 'next-station route-color';
                    
                    if (stationIndex === 0) stationDiv.classList.add('current');
                    if (stop.stop_id === finalStopId) stationDiv.classList.add('last-station');
                    
                    const stationText = document.createElement('span');
                    stationText.className = 'station-text';
                    stationText.textContent = getStationName(stop.stop_id);
                    
                    stationDiv.appendChild(stationText);
                    columns[colIndex].appendChild(stationDiv);
                    
                    stationIndex++;
                }
            }
        };

        const calculateDuration = (scheduledTime, estimatedTime) => {
            const departureTime = new Date(estimatedTime || scheduledTime);
            const now = new Date();
            const diffMinutes = Math.floor((departureTime - now) / 60000);
            
            if (diffMinutes < 1) return "Now";
            if (diffMinutes < 60) return `${diffMinutes} min`;
            const hours = Math.floor(diffMinutes / 60);
            const mins = diffMinutes % 60;
            return `${hours}h ${mins}m`;
        };

        // --- settings toggle ---
        const toggleSettings = () => {
            const isVisible = settingsPanel.classList.toggle('visible');            
            settingsButton.setAttribute('aria-expanded', isVisible);            
            // Change the SVG color to indicate it's open/closed
            const svgPath = settingsButton.querySelector('svg path:nth-child(1)');
        };

        const updateBoard = async () => {
            try {
                const response = await fetch(getDepartureApiUrl());
                
                if (!response.ok) {
                    if (response.status === 404) {
                        showNoDeparturesMessage(currentPlatform);
                        currentRunId = null; // Reset when no departures
                        return;
                    }
                    throw new Error('API response failed');
                }

                const data = await response.json();
                console.log('API Response:', data);

                if (data.platform_number === null) {
                    showNoDeparturesMessage(currentPlatform);
                    currentRunId = null;
                    return;
                }

                if (currentPlatform && data.platform_number !== currentPlatform) {
                    showNoDeparturesMessage(currentPlatform);
                    currentRunId = null;
                    return;
                }

                const { route_id, platform_number, scheduled_departure_utc, estimated_departure_utc, delay_minutes, final_stop_id, run_id } = data;
                
                // Detect if this is a new train service
                const isNewService = run_id !== currentRunId;
                
                if (isNewService) {
                    console.log('New service detected, updating station list');
                    currentRunId = run_id;
                    
                    // Update route colors for new service
                    const colors = routeColors[route_id];
                    if (colors) {
                        departureItem.style.setProperty('--route-bg-color', colors.background);
                        departureItem.style.setProperty('--route-text-color', colors.text);
                    }
                    
                    // Update platform and station name
                    if (platformElement) platformElement.textContent = platform_number || '?';
                    if (headerPlatformElement) headerPlatformElement.textContent = platform_number || '?';
                    if (stationNameElement) stationNameElement.textContent = getStationName(currentStopId);
                    
                    const destinationName = getStationName(final_stop_id);
                    if (destinationElement) destinationElement.textContent = destinationName;
                    
                    // Fetch and update stops for new service
                    const stops = await loadStoppingPattern(run_id);
                    
                    const nextStationsDiv = document.querySelector('.route-info');
                    if (nextStationsDiv.querySelector('.no-trains')) {
                        restoreNormalDisplay();
                    }
                    
                    if (stops) {
                        const expressInfo = populateStationDivs(stops, currentStopId, final_stop_id, route_id);
                        
                        let routeInfo = analyzeInboundRoute(stops, currentStopId);
                        if (!routeInfo) {
                            routeInfo = analyzeOutboundRoute(stops, currentStopId, expressInfo);
                        }
                        
                        // Find the element again (it's the <span> inside the .route-info container)
                        const currentRouteInfoElement = document.querySelector('.route-info span');

                        if (currentRouteInfoElement && routeInfo) {
                            // Use the newly found, live element
                            currentRouteInfoElement.textContent = routeInfo;
                        }
                    }
                }
                
                // ALWAYS update these (they change even for same service)
                if (departureTimeElement) {
                    let timeString = new Date(scheduled_departure_utc).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                    timeString = timeString.replace('AM', 'am').replace('PM', 'pm');
                    departureTimeElement.textContent = timeString;
                }
                
                if (delayIndicatorElement) {
                    if (delay_minutes >= 2) {
                        delayIndicatorElement.textContent = `+${delay_minutes}`;
                    } else {
                        delayIndicatorElement.textContent = '';
                    }
                }
                
                if (durationElement) {
                    durationElement.textContent = calculateDuration(scheduled_departure_utc, estimated_departure_utc);
                }
                
                if (lastUpdatedElement) {
                    lastUpdatedElement.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                }

            } catch (error) {
                console.error('Error:', error);
                currentRunId = null;
                if (lastUpdatedElement) {
                    lastUpdatedElement.textContent = 'Error loading data';
                }
            }
        };
        
        const headerHeight = headerElement.scrollHeight;
        stationBoardElement.style.setProperty('--header-height', `${headerHeight}px`);

        settingsButton.addEventListener('click', toggleSettings);

        Promise.all([loadStations(), loadRouteOrder()]).then(() => {
            populateStationDropdown();
            updatePlatformDropdown();
            updateBoard();
            setInterval(updateBoard, 20000);
        });
    });
    </script>